---

---

<div id="visualisation">
  <div id="heatmap"></div>
  <!-- <div id="bar" class="chart-container"></div> -->
</div>

<div id="controls">
  <label for="infrastructure-select">Select Infrastructure Type:</label>
  <select id="infrastructure-select">
    <option value="all">All</option>
    <option value="sewer_and_water">Sewer and Water</option>
    <option value="power">Power</option>
    <option value="roads_and_bridges">Roads and Bridges</option>
    <option value="medical">Medical</option>
    <option value="buildings">Buildings</option>
  </select>
</div>

<style>
  /* #visualisation {
    display: grid;
    grid-template-columns: 1fr 1fr;
  }

  #map {
    position: relative;
  }

  .legend {
    position: absolute;
    top: 200px;
    left: 30px;
  } */
</style>

<script>
  import * as d3 from "d3";
  import * as Plot from "@observablehq/plot";

  interface ReportRow {
    location: number;
    time: Date;
    sewer_and_water: number;
    power: number;
    roads_and_bridges: number;
    medical: number;
    buildings: number;
    shake_intensity: number;
  }

  interface AggregatedReportRow {
    location: number;
    damage: number;
    count: number;
    shake_intensity: number;
  }

  let rawData: ReportRow[];
  let processedData: Map<number, AggregatedReportRow>;

  // Runs once on load
  async function init() {
    // Fetch CSV
    rawData = await d3.csv("reports.csv", (d) => ({
      ...d,
      location: +d.location,
      time: new Date(d.time),
      sewer_and_water: +d.sewer_and_water,
      power: +d.power,
      roads_and_bridges: +d.roads_and_bridges,
      medical: +d.medical,
      buildings: +d.buildings,
      shake_intensity: +d.shake_intensity,
    }));

    // Sort by Date
    rawData.sort((a, b) => a.time.getTime() - b.time.getTime());

    // Initial update
    update();
  }

  // Used to update the data frame and rerender the charts (runs everytime a change is made)
  function update() {
    // Aggregate the Raw Data
    const grouped = d3.group(rawData, (d) => d.location);
    const aggregated = new Map<number, AggregatedReportRow>();
    for (const [location, records] of grouped) {
      let damage: number;
      let count: number;

      if (selectedInfrastructure === "all") {
        const values = [
          d3.mean(records, (d) => d.sewer_and_water) ?? NaN,
          d3.mean(records, (d) => d.power) ?? NaN,
          d3.mean(records, (d) => d.roads_and_bridges) ?? NaN,
          d3.mean(records, (d) => d.medical) ?? NaN,
          d3.mean(records, (d) => d.buildings) ?? NaN,
        ].filter((v) => !isNaN(v));
        // damage = values.length > 0 ? (d3.mean(values) ?? NaN) : NaN;
        damage = d3.mean(values) ?? NaN;
        count = records.length;
      } else {
        damage =
          d3.mean(
            records,
            (d) => d[selectedInfrastructure as InfrastructureKey]
          ) ?? NaN;
        count = records.filter(
          (d) => !isNaN(d[selectedInfrastructure as InfrastructureKey])
        ).length;
      }

      const shake_intensity = d3.mean(records, (d) => d.shake_intensity) ?? NaN;

      aggregated.set(location, {
        location,
        damage,
        count,
        shake_intensity,
      });
    }

    processedData = aggregated;
    heatmap();
  }

  // Used to render the heatmap
  function heatmap() {
    const container = document.getElementById("bar");
    if (!container) return;

    const plot = Plot.plot({
      // width,
      // height: 930,
      // marginBottom: 30,
      // padding: 0,
      // round: false,
      // label: null,
      x: { axis: "top" },
      color: {
        scheme: "purd",
        legend: true,
        type: "sqrt",
        label: "Cases per 100,000 people",
      },
      marks: [
        Plot.barX(
          vaccines.filter((d) => d.disease === disease),
          {
            x: "date",
            y: "state",
            interval: "year",
            inset: 0.5,
            fill: "cases",
            // title: "cases"
            tip: true,
          }
        ),
        Plot.ruleX([introductions.find((d) => d.disease === disease)], {
          x: "date",
        }),
        Plot.text([introductions.find((d) => d.disease === disease)], {
          x: "date",
          dy: 4,
          lineAnchor: "top",
          frameAnchor: "bottom",
          text: (d) => `${d.date.getUTCFullYear()}\nVaccine introduced`,
        }),
      ],
    });

    container.innerHTML = "";
    container.appendChild(plot);
  }

  // // Used to render the bar chart
  // function bar() {
  //   const container = document.getElementById("bar");
  //   if (!container) return;

  //   const locations = [
  //     "Palace Hills",
  //     "Northwest",
  //     "Old Town",
  //     "Safe Town",
  //     "Southwest",
  //     "Downtown",
  //     "Wilson Forest",
  //     "Scenic Vista",
  //     "Broadview",
  //     "Chapparal",
  //     "Terrapin Springs",
  //     "Pepper Mill",
  //     "Cheddarford",
  //     "Easton",
  //     "Weston",
  //     "Southton",
  //     "Oak Willow",
  //     "East Parton",
  //     "West Parton",
  //   ];

  //   const data = locations.map((name, id) => ({
  //     location: name,
  //     data: processedData.get(id + 1),
  //   }));

  //   const plot = Plot.plot({
  //     width: 500,
  //     height: 400,
  //     marginLeft: 120,
  //     color,
  //     x: {
  //       label: `Aggregate (mean) Reported ${infrastructure[selectedInfrastructure as InfrastructureKey]} damage`,
  //       domain: [0, 10],
  //     },
  //     y: {
  //       label: "Neighbourhood",
  //     },
  //     marks: [
  //       Plot.barX(data, {
  //         x: (d) => d.data?.damage,
  //         y: "location",
  //         sort: { y: "-x" },
  //         fill: (d) => bivariateClass(d.data),
  //         title: (d) => {
  //           const name = d.location;
  //           const value = d.data;

  //           if (!value || (isNaN(value.damage) && isNaN(value.count)))
  //             return `${name}\nno data`;

  //           const [reports, damage] = bivariateClass(value);
  //           return (
  //             `${name}\n` +
  //             `${infrastructure[selectedInfrastructure]} Damage: ${
  //               isNaN(value.damage) ? "No Data" : value.damage.toFixed(1)
  //             }/10 ${damage != null ? labels[damage] : " unknown"}\n` +
  //             `# of Reports: ${
  //               isNaN(value.count) ? "No Data" : value.count
  //             } ${reports != null ? labels[reports] : " (unknown)"}\n` +
  //             `Shake Intensity: ${value.shake_intensity.toFixed(1)}/10`
  //           );
  //         },
  //         tip: true,
  //       }),
  //       Plot.text(data, {
  //         x: (d) => d.data?.damage,
  //         y: "location",
  //         text: (d) => d.data?.damage.toFixed(1),
  //         dx: 4,
  //         dy: 0.5,
  //         textAnchor: "start",
  //         stroke: "white",
  //         fill: "black",
  //         fontSize: 12,
  //       }),
  //     ],
  //   });

  //   container.innerHTML = "";
  //   container.appendChild(plot);
  // }

  // Infrasturcture select
  const infraSelect = document.getElementById(
    "infrastructure-select"
  ) as HTMLSelectElement;

  type InfrastructureKey = Exclude<
    keyof ReportRow,
    "location" | "time" | "shake_intensity"
  >;
  type SelectedKey = InfrastructureKey | "all";
  let selectedInfrastructure: SelectedKey = "all";

  infraSelect.addEventListener("change", () => {
    selectedInfrastructure = infraSelect.value as SelectedKey;
    update();
  });

  init();
</script>
