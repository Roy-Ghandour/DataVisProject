---

---

<label for="time-slider">Select Time:</label>
<div style="width: 80vw; margin-left: 10vw;">
  <input type="range" id="time-slider" min="0" step="1" />
</div>
<span id="time-label-1">Loading...1</span>
<span style="margin-left:100px;" id="time-label-2">Loading...2</span>
<br />
<label for="interval-select">Select Time Interval (hours):</label>
<select id="interval-select">
  <option value="1">1 Hour</option>
  <option value="2">2 Hours</option>
  <option value="3">3 Hours</option>
  <option value="4">4 Hours</option>
  <option value="5">5 Hours</option>
  <option value="6">6 Hours</option>
</select>

<div id="map"></div>

<script>
  import * as d3 from "d3";
  import * as Plot from "@observablehq/plot";

  interface ReportRow {
    location: number;
    time: Date;
    sewer_and_water: number;
    power: number;
    roads_and_bridges: number;
    medical: number;
    buildings: number;
    shake_intensity: number;
  }

  interface AggregatedReportRow {
    location: number;
    sewer_and_water: number;
    power: number;
    roads_and_bridges: number;
    medical: number;
    buildings: number;
    shake_intensity: number;
  }

  let geoData: GeoJSON.FeatureCollection;
  let rawData: ReportRow[];
  let rawDataBuckets: ReportRow[][];
  let processedData: Map<number, AggregatedReportRow>;

  async function init() {
    // Fetch GeoJSON Data for Choropleth Map
    geoData = await fetch("StHitmark.geojson").then((res) => res.json());

    // Fetch CSV
    rawData = await d3.csv("reports.csv", (d) => ({
      ...d,
      location: +d.location,
      time: new Date(d.time),
      sewer_and_water: +d.sewer_and_water,
      power: +d.power,
      roads_and_bridges: +d.roads_and_bridges,
      medical: +d.medical,
      buildings: +d.buildings,
      shake_intensity: +d.shake_intensity,
    }));

    // Sort by Date
    rawData.sort((a, b) => a.time.getTime() - b.time.getTime());

    // Sort Raw Data into 60 minute buckets
    rawDataBuckets = Array.from({ length: 121 }, () => []);
    let startTime = new Date("2020-04-6 00:00:00").getTime();
    for (const row of rawData) {
      const elapsedMs = row.time.getTime() - startTime;
      const bucketIndex = Math.floor(elapsedMs / (60 * 60 * 1000)); // 60 min * 60 sec * 1000 ms

      rawDataBuckets[bucketIndex].push(row);
    }

    // UI
    tsUpdate();

    // Initial update
    update();
  }

  // Used to update the data frame
  function update() {
    // Filter the raw Data
    let filtered: ReportRow[] = [];
    // we are selecting things that are out of bounds need a fallback
    for (let i = 0; i < tsInterval; i++) {
      if (tsSelected + i > tsMaxSteps) break;
      filtered.push(...rawDataBuckets[tsSelected + i]);
    }

    // Aggregate the Filtered Data
    const grouped = d3.group(filtered, (d) => d.location);
    const aggregated = new Map<number, AggregatedReportRow>();
    for (const [location, records] of grouped) {
      aggregated.set(location, {
        location,
        sewer_and_water: d3.mean(records, (d) => d.sewer_and_water) ?? NaN,
        power: d3.mean(records, (d) => d.power) ?? NaN,
        roads_and_bridges: d3.mean(records, (d) => d.roads_and_bridges) ?? NaN,
        medical: d3.mean(records, (d) => d.medical) ?? NaN,
        buildings: d3.mean(records, (d) => d.buildings) ?? NaN,
        shake_intensity: d3.mean(records, (d) => d.shake_intensity) ?? NaN,
      });
    }

    processedData = aggregated;
    render();
  }

  // Used to render the choropleth map
  function render() {
    const container = document.getElementById("map");
    if (!container) return;

    const plot = Plot.plot({
      width: 800,
      height: 500,
      x: { ticks: "none" },
      y: { ticks: "none" },
      color: {
        type: "quantize",
        scheme: "blues",
        label: "Value",
        legend: true,
        domain: [1, 10],
        n: 9,
      },
      marks: [
        Plot.geo(geoData, {
          fill: (d) => processedData.get(d.properties.Id)?.sewer_and_water,
          stroke: "white",
          strokeWidth: 0.7,
          title: (d) => {
            const value = processedData.get(d.properties.Id)?.sewer_and_water;
            return `${d.properties.Nbrhood}\n${
              typeof value === "number" ? value.toFixed(2) : "No data"
            }`;
          },
          tip: true,
        }),
      ],
    });

    container.innerHTML = "";
    container.appendChild(plot);
  }

  // Time Slider
  const tsSlider = document.getElementById("time-slider") as HTMLInputElement;
  const tsLabelStart = document.getElementById("time-label-1") as HTMLElement;
  const tsLabelEnd = document.getElementById("time-label-2") as HTMLElement;

  const tsMaxSteps = 120;
  let tsSelected = 0;
  let tsInterval = 1;

  tsSlider.value = "0";
  tsSlider.step = "1";
  tsSlider.max = (tsMaxSteps - 1).toString();

  function tsUpdate() {
    const tsGenerateTimestamp = (n: number): string => {
      return new Date(Date.UTC(2020, 3, 6, n, 0, 0))
        .toLocaleString("sv-SE", { timeZone: "UTC" })
        .replace("T", " ");
    };

    tsInterval = parseInt(intervalSelect.value, 10);
    tsSlider.step = tsInterval.toString();

    tsSelected = +tsSlider.value;

    tsLabelStart.textContent = tsGenerateTimestamp(tsSelected);
    tsLabelEnd.textContent =
      tsGenerateTimestamp(tsSelected + tsInterval) ?? tsGenerateTimestamp(120);

    update();
  }

  tsSlider.addEventListener("input", tsUpdate);

  // Time Interval Select
  const intervalSelect = document.getElementById(
    "interval-select"
  ) as HTMLSelectElement;

  intervalSelect.addEventListener("change", tsUpdate);

  init();
</script>
